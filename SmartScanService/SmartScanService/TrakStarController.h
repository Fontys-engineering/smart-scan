#pragma once

#include <time.h>
#include <string>
#include <fstream>
#include <vector>

#include "Point3.h"
#include "NDI/ATC3DG.h"

namespace SmartScan
{
	class CSystem
	{
	public:
		SYSTEM_CONFIGURATION	m_config;
	};

	class CSensor
	{
	public:
		SENSOR_CONFIGURATION	m_config;
	};

	class CXmtr
	{
	public:
		TRANSMITTER_CONFIGURATION	m_config;
	};

    // This class handles the communication with the TrakSTAR hardware
    // Functionality such as correct configuration, starting, stopping the scan and
    // Getting new data is handled here.
	class TrakStarController
	{
	public:
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="mock">when true, the TrakStarController will not attempt to use hardware TrakStar and use Mock data instead</param>
		/// <returns></returns>
		TrakStarController(bool mock = false);

		/// <summary>
		/// Initialie the system. Call this before making a measurement
		/// </summary>
		void Init();

		/// <summary>
		/// Configure the sensor system. Call this after init and before making a measurement.
		/// </summary>
		void Config();

		/// <summary>
		/// Attach the transmitter to the system. Call this before making a measurement.
		/// </summary>
		void AttachTransmitter();
    
        /// <summary>
        /// Try and find the device channel from a specific serial number.
        /// </summary>
        int GetSensoridFromSerial(int serialNumber);

        /// <summary>
        /// Get the port numbers of the attached sensors.
        /// </summary>
		std::vector<int> GetAttachedSensors();

		/// <summary>
		/// Returns the number of sensors in the current config
		/// </summary>
		/// <returns> - number of sensors available</returns>
		int GetNSensors();

		/// <summary>
		/// Get the latest record for a specific sensor
		/// </summary>
		/// <param name="sensorID"> - The ID of the sensor from which the record will be returned</param>
		/// <returns> - The sensor record</returns>
		Point3 GetRecord(int sensorID);

		/// <summary>
		/// Reads a number of records for all sensors and prints it to console.
		/// </summary>
		void ReadSensor();

		/// <summary>
		/// Turn off the referenece.
		/// </summary>
		void StopTransmit();
	private:
		bool mMock;

		std::string s0MockDataFilePath = "MockData/s0.csv";
		std::string s1MockDataFilePath = "MockData/s1.csv";
		std::string s2MockDataFilePath = "MockData/s2.csv";

		std::ifstream s0MockDataFile;
		std::ifstream s1MockDataFile;
		std::ifstream s2MockDataFile;

		long mockDataFileLine = 0;
		long mockDataFileNOfLines;

		CSystem			ATC3DG;
		CSensor*		pSensor;
		CXmtr*			pXmtr;

		/// Keep track of the last mock record so that the movement is realistic.
		Point3 mPrevMockRecord;

		void DeviceStatusHandler(int deviceStatus);

		void ErrorHandler(int error);

		const std::string GetErrorString(int error);
		
		/// <summary>
		/// Randomly returns a point on the edge of a sphere at a reasonable distance from the previous point.
		/// </summary>
		/// <returns></returns>
		Point3 GetMockRecord();

		/// <summary>
		/// Goes through the specified file and returns consecutive samples as Point3.
		/// </summary>
		/// <returns></returns>
		Point3 GetMockRecordFromFile(int sensorId = 0);
		
	};
}

//////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
//
//	MACROS for simplifying the procedure calls
//
// This macro will set a system parameter and call the error handler if there is 
// an error reported. Note These macros do not print to the standard output the
// set value

#define SET_SYSTEM_PARAMETER(type, value)										\
	{																			\
		type##_TYPE buffer = value;												\
		type##_TYPE *pBuffer = &buffer;											\
		errorCode = SetSystemParameter(type, pBuffer, sizeof(buffer));			\
		if(errorCode!=BIRD_ERROR_SUCCESS) ErrorHandler(errorCode);				\
	}

#define	SET_SENSOR_PARAMETER(sensor, type, value)								\
	{																			\
		type##_TYPE buffer = value;												\
		type##_TYPE *pBuffer = &buffer;											\
		errorCode = SetSensorParameter(sensor, type, pBuffer, sizeof(buffer));	\
		if(errorCode!=BIRD_ERROR_SUCCESS) ErrorHandler(errorCode);				\
	}

#define	SET_TRANSMITTER_PARAMETER(xmtr, type, value)							\
	{																			\
		type##_TYPE buf = value;												\
		type##_TYPE *pBuf = &buf;												\
		errorCode = SetTransmitterParameter(xmtr, type, pBuf, sizeof(buf));		\
		if(errorCode!=BIRD_ERROR_SUCCESS) ErrorHandler(errorCode);				\
	}

// In order for the above macros to compile without error it is necessary 
// to provide typedefs for all the XXX_TYPEs that are generated by "type##_TYPE"
typedef short					SELECT_TRANSMITTER_TYPE;
typedef double					POWER_LINE_FREQUENCY_TYPE;
// AGC_MODE_TYPE already defined as an enumerated type
typedef double					MEASUREMENT_RATE_TYPE;
typedef	double					MAXIMUM_RANGE_TYPE;
typedef BOOL					METRIC_TYPE;
// DATA_FORMAT_TYPE already defined as an enumerated type
typedef DOUBLE_ANGLES_RECORD	ANGLE_ALIGN_TYPE;
typedef DOUBLE_ANGLES_RECORD	REFERENCE_FRAME_TYPE;
typedef	BOOL					XYZ_REFERENCE_FRAME_TYPE;
// HEMISPHERE_TYPE already defined as an enumerated type
typedef	BOOL					FILTER_AC_WIDE_NOTCH_TYPE;
typedef	BOOL					FILTER_AC_NARROW_NOTCH_TYPE;
typedef	double					FILTER_DC_ADAPTIVE_TYPE;
typedef	ADAPTIVE_PARAMETERS		FILTER_ALPHA_PARAMETERS_TYPE;
typedef	BOOL					FILTER_LARGE_CHANGE_TYPE;
typedef	QUALITY_PARAMETERS		QUALITY_TYPE;